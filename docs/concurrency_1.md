# Concurrency Chapter 1

### 프로세스

> 프로세스는 실행 중인 애플리케이션의 인스턴스

### 스레드

- 실행 스레드는 프로세스가 실행할 일련의 명령을 포함
- 프로세스는 최소한 하나의 스레드를 포함하며 이 스레드는 애플리케이션의 진입점을 실행하기 위해 생성
- 스레드를 블록한다는 것은 스레드에서 코드의 실행을 중지한다는 의미
    - 사용자와 상호작용하는 스레드는 블록이 되지 않아야함

### 코루틴

- 경량 스레드
- 코루틴이 프로세서가 실행할 명령어 집합의 실행을 정의
- 코루틴은 스레드 안에서 실행
- 스레드 하나에 많은 코루틴이 있을 수 있지만, 주어진 시간에 하나의 스레에서 하나의 명령만이 실행될 수 있음
- 같은 스레드에 10개의 코루틴이 있다면 해당 시점에는 하나의 코루틴만 실행
- 코루틴은 기본적으로 특정 스레드에서 시작되지만, 어느 시점이 지나 다른 스레드에서 다시 시작

### 스레드와 코루틴의 가장 큰 차이

> 스레드에 비해 코루틴이 빠르고 적은 비용으로 생성할 수 있음

### 코루틴의 실행 동작

- 코루틴이 일시 중단되는 동안 실행 중인 스레드는 다른 코루틴을 실행하는데 사용되며, 코루틴은 시작 또는 재개될 준비 상태로 변함
- 코루틴이 특정 스레드 안에서 실행되더라도 스레드와 묶이지 않음 (스레드 의존적이지 않음)
- 코루틴의 일부를 특정 스레드에서 실행하고, 실행을 중지한 다음 나중에 다른 스레드에서 계속 실행하는 것이 가능
    - 코틀린이 실행 가능한 스레드로 코루틴을 이동시키기 때문이다.
    - 스레드는 한 번에 하나의 코루틴만 실행할 수 있기 때문에 프레임워크가 필요에 따라 코루틴을 스레드들 사이에 옮기는 역할을 함

### 동시성

- 애플리케이션이 동시에 한 개 이상의 스레드에서 실행될 때 발생하는 현상
- 두 개 이상의 알고리즘의 실행 시간이 겹쳐질 때 발생
    - 단일 코어에서는 서로 다른 스레드의 인스트럭션을 교차 배치해서, 스레드들의 실행을 효율저긍로 겹쳐서 실행

### 순차코드

- 정확한 실행 순서를 쉽게 알 수 있어서 예측하지 못한 일이 벌어지지 않음
    - 단, 동시성 코드에 비해 성능 저하
    - 단, 코드가 실행되는 하드웨어를 제대로 활용 어려움

### 동시성은 병렬과 다르다.

- 동시성은 작업을 작게 쪼개어, 유휴시간에 스레드에 작업을 나누어 실행하게 함
- 병렬은 멀티코어 상황에서 2개의 코어에 각각의 스레드 작업을 넘김 (정말로 같은 시간에 두개의 작업이 수행)

### CPU 바운드

> CPU만 완료하면 되는 작업을 중심으로 구현되는 알고리즘, 알고리즘의 성능은 실행 중인 CPU의 성능에 좌우되며 CPU만 업그레드해도 성능이 향상

### IO 바운드

> 입출력 장치에 의존하는 알고리즘, 네트워킹이나 컴퓨터 주변기기로부터의 입력을 받는 작업들도 IO 작업,
> IO 작업을 기준으로 성능에 대한 병목 현상을 일으키고, 최적화가 외부 시스템이나 장치에 의존적

### CPU 바운드 알고리즘에서의 동시성과 병렬성

> 다중 코어에서 병렬성을 활용하면 성능을 향상시킬 수 있지만, 단일 코어에서 동시성을 구현하면 성능이 저하

단일 코어에서 여러번 컨텍스트 스위칭이 발생하면 전체 프로세스에 오버헤드가 발생할 수 있음

### IO 바운드 알고리즘에서의 동시성 대 병렬성

> 순차적인 알고리즘보다 동시성 구현에서 항상 더 나은 성능을 발휘할 것으로 예상돼 IO 작업은 늘 동시성으로 싱행하는 편이 좋음

### 레이스 컨디션

> 코드를 동시성으로 작성했지만, 순차적 코드처럼 동작할 것이라고 예상할 때 발생, 동시성 코드가 항상 특정한 순서로 실행될 것이라 가정하고 오해할 때 생김

레이스 컨디션은 동시성 코드 일부가 제대로 작동하기 위해 일정한 순서로 완료돼야 할 때 발생

### 원자성 위반

> 원자성 작업이란 작업이 사용하는 데이터를 간섭 없이 접근할 수 있음

원자성은 객체의 상태가 동시에 수정될 수 있을 때 필요하며 그 상태의 수정이 겹치지 않도록 보장해야 함, 수정이 겹칠 수 있다는 것은 데이터 손실이 발생할 수 있음을 의미

### 교착 상태

> 다른 스레드에서 작업이 완료되는 동안 실행을 일시 중단하거나 차단됨, 순환적 의존성으로 인해 전체 애플리케이션의 실행이 중단되는 상황

### 라이브 락

> 애플리케이션이 올바르게 실행을 계속할 수 없을 떄 발생하는 교착 상태와 유사, 애플리케이션이 정상 실행으로 돌아오지 못하게 하는 방향으로 상태가 변함
> 교착상태를 복구하도록 설계된 알고리즘에서 발생할 수 있음, 복구 시도하면 다시 교착상태로 돌아가는...

### 넌 블로킹

- 코틀린은 스레드의 실행을 블로킹하지 않으면서, 잠시 실행을 중단하는 suspendable Computations 기능을 제공
- 스레드를 멈추지 않고, 다른 연산 작업을 사용할 수 있음

### 기본 코틀린 동시성 함수

- newSingleThreadContext()
- newFixedThreadPoolContext()
- CommonPool()
- 코루틴
- 채널, 뮤텍스, 스레드 한정

### 코틀린 동시성 기본형

- channels (채널) : 코루틴 간에 데이터를 안전하게 보내고 받는데 사용할 수 있는 파이프
- Worker pools (작업자 풀) : 많은 스레드에서 연산 집합의 처리를 나눌 수 있는 코루틴의 풀
- Actors (액터) : 채널과 코루틴을 사용하는 상태를 감싼 래퍼로 여러 스레드에서 상태를 안전하게 수정하는 매커니즘을 제공
- Mutexes (뮤텍스) : 크리티컬 존(critical zone) 영역을 정의해 한 번에 하나의 스레드만 실행할 수 있도록 하는 동기화 매커니즘, 크리티컬 존에 액세스하려는 코루틴은 이전 코루틴이 크리티컬 존을
  빠져나올 때까지 일시 정지
- Thread Confinement (스레드 한정) : 코루틴의 실행을 제한해서 지정된 스레드에서만 실행하도록 하는 기능
- 생성자 (반복자 및 시퀀스) : 필요에 따라 정보를 생성할 수 있고 새로운 정보가 필요하지 않을 때 일시 중단될 수 있는 데이터 소스

### 일시 중단 연산 (Suspending Computations)

> 해당 스레드를 차단하지 않고 실행을 일시 중지할 수 있는 연산, 스레드를 차단하는 것은 불편하기 때문에 자체 실행을 일시 중단하면 일시 중단 연산을 통해 스레드를 다시 시작해야 할 때까지 스레드를 다른 연산에서 사용할 수 있게함

### 람다 일시 중단

> 일시 중단 함수를 호출함으로써 자신의 실행을 중단할 수 있음

### 코루틴 디스패처

> 코루틴을 시작하거나 재개할 스레드를 결정하기 위해 사용, 모든 코루틴 디스패처는 CoroutineDispatcher 인퍼에시를 구현

- DefaultDispatcher : == CommonPool
- CommonPool : 공유된 백그라운드 스레드 풀에서 코루틴을 실행하고 다시 시작함, defaut size는 CPU Bound 작업에 사용하기 적합
- Unconfined : 현재 스레드에서 코루틴을 시작하지만 어떤 스레드에서도 코루틴이 다시 재개될 수 있음, 디스패처에서는 스레드 정책을 사용하지 않음

### 디스패처 스레드 풀

- newSingleThreadContext() : 단일 스레드로 디스패처 사용, 항상 같은 스레드에서 시작되고 재개
- newFixedThreadPoolContext() : 지정된 크기의 스레드 풀이 있는 디스패러 생성, 런타임은 디스패처에서 실행된 코르틴을 시작하고 재개할 스레드를 결정

### 코루틴 빌더

> 일시 중단 람다를 받아 그것을 싱행시키는 코루틴을 생성하는 함수

- async() : 결과가 예상되는 코루틴을 시작하는데 사용, 코루틴 내부에서 일어나는 모든 예외를 갭처해서 결과에 넣기 때문에 조심해서 사용, Deferred<T> 반환
- launch() : 결과를 반환하지 않는 코루틴 시작, 자체 혹은 자식 코루틴 실행을 취소하기 위해 사용하는 Job반환
- runBlocking() : 블로킹 코드를 일시 중지 가능한 코드로 연결하기 위해 작성, 코루틴의 실행이 끝날때까지 현재 스레드를 차단
