# 채널 - 통신을 통한 메모리 공유

### 동시성 이슈

- 서로 다른 스레드 간에 메모리를 공유할 때 자주 발생
- 다른 스레드에 의해 현재 사용중인 객체의 값이 변경되는 경우
- 방탄 동기화가 없으면 위험하며, 공유 객체로 들어가지 않아야 하는 상태에 빠질때 발생
- 데드락, 레이스 컨디션, 원자서 위반 등
- 공유 상태가 유효하지 않기 때문에 발생 -> 상태가 일관성을 잃어버리는 원인으로

코틀린은 동시성 이슈를 채널이라는 기능으로 해결할려고 함 -> 채널은 스레드가 서로 상태를 공유하는 대신, 메시지를 주고받는 통신을 하도록 함

### 채널?

- 동시성 코드 간에 서로 안전한 통신을 할 수 있도록 해주는 도구
- 동시성 코드가 메시지를 보내 통신
- 실행 중인 스레드에 상관없이 서로 다른 코루틴 간에 메시지를 안전하게 보내고 받기 위한 파이프라인

### 채널 예시

데이터를 가져오고, 그것을 처리하는 로직이 있다고 하면, 데이터를 가져오는 부분과 그것을 처리하는 로직을 분리하고 그 사이를 채널을 통해 연결

각 파트를 분리하기 때문에 부하분산에 용이

### 배압

- 리시버가 실제로 처리할 수 있는 것보다 더 많은 요소들로 채널이 넘치지 않도록 함
- 채널에 대한 버퍼 정의 > 채널 안의 요소가 버퍼 크기에 도달하면 일시 중단 > 채널에 요소가 제거되면 재개

### 언버퍼드 채널
> 버퍼가 없는 채널

- RendezvousChannel
- 버퍼가 전혀 없어서 그 채널에서 send()를 호출하면 리시버가 receive()를 호출할 때까지 일시 중지

### 버퍼드 채널
> 버퍼를 가지는 채널, 채널 내 요소의 수가 버퍼의 크기와 같을 때마다 송신자의 실행을 중지

- LinkedListChannel
- 중단 없이 무한의 요소를 전송할 수 있는 채널
- 어떤 송신자도 중단하지 않음
- 메모리를 너무 많이 소모할 수 있기 대문에, 요구사항과 대상 디바이스에 기반하는 버퍼 크기를 갖는 버퍼드 채널을 사용하는 것을 권장

### ArrayChannel
> 버퍼 크기를 0부터 최대 int.MAX_VALUE-1 까지 가짐, 가지고 있는 요소의 양이 버퍼 크기에 이르면 송신자를 일시 중단

- 버퍼가 가득 차면 송신자를 일시 중지

### ConflatedChannel
> 내보낸 요소가 유실돼도 괜찮음, 하나의 요소의 버퍼만 갖고 있고, 새로운 요소가 보내질 대마다 이전 요소는 유실, 송신자가 절대로 일시 중지되지 않는다는 것을 의미

### verify Channel

**보내기 전 검증**
- isClosedForSend : 전송을 위한 채널이 닫히지 않았는지 확인
- isFull : 채널이 가득 찬 상태

**요소 전송**
- send() : 채널을 통해 요소 전송

**요소 제공**
- offer() : 대기열에 추가할 요소를 가지며, 채널의 상태에 따라 Boolean을 반환하거나 예외를 발생 (ClosedSendChannelException)

**읽기 전 유효성 검사**
- isClosedForReceive : 수신에 대해 닫힌 채널인지 여부를 나타내는 isClosedForReceive 속성 확인 -> recive 호출시 ClosedReceiveChannelException 발생
- isEmpty : 수신할 것인 여부 확인
