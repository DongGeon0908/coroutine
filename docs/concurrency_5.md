# 이터레이터, 시퀀스 그리고 프로듀서

### 일시중단 가능 이터레이터와 일시중단 가능 시퀀스의 주요 특징

- 호출 사이에서 일시 중담되지만, 실행 중에는 일시 중단될 수 없음
- 일시 중단 연산이 없어도 반복 가능
- CoroutineContext를 빌더에서 받지 않음 -> 코드를 호출한 컨텍스트와 동일하다고 판단
- 정보 산출 후에만 일시 중지 가능 -> yield(), yiedldAll()

### 값 산출

- 값을 산출하면 값이 다시 요청될 때까지 시퀀스 또는 이터레이터가 일시 중단

### 이터레이터

- 요소들의 컬렉션을 순서대로 살펴보는데 유용
- 인덱스 검색 불가
- hasNext()로 요소가 더 있는지 확인 가능
- 한 방향으로만 검색 가능, 이전 요소 검색 불가
- 재설정 할 수 없고, 한 번만 반복 가능

**모든 요소 보기**

- forEach()
- forEachRemaing() -> 해당 시점까지 일부 요소가 이터레이터에 없을 수 있음을 명확히 표현

**다음 값 가져오기**

- next()

**요소가 더 있는지 검증**

- hashNext()

**요소를 검증하지 않고 next() 호출**

- 검색할 요소가 있는지 확인하지 않으면, 실행 중에 NoSuchElementException 발생

**hasNext()**

- hasNext()가 작동하려면 런타임은 코루틴 실행을 재개
- hashNext() 호출로 인해 값이 산출되면 값이 유지되다가 다음 next() 호출때 반환

### 시퀀스

- 인덱스로 값 가져옴
- 상태 저장 X, 상호 작용한 후, 자동으로 재설정
- 한 번의 호출로 값 그룹을 가져올 수 있음

**모든 요소 보기**

- forEach()
- forEachIndexed() -> 값과 함께 값의 인덱스를 제공

**elementAt**

- 인덱스를 가져와 해당 위치의 요소를 반환

**elemnentAtOrElse**

- 주어진 인덱스에 요소가 없으면 람다로 실행

**elementAtOrNull**

- 인덱스를 가져와서 T?를 반환

### 프로듀서

- 값이 생성된 후 일시 중단되며, 새로운 값이 요청될 때 다시 재개
- 특정 CoroutineContext로 생성 가능
- 전달되는 일시 중단 람다의 본문은 언제든지 일시 중단 가능
- 어느 시점에든 중단 가능 -> 일시 중단 연산에서만 수신
- 채널을 사용해 작동하므로 데이터를 스트림처럼 생각할 수 있음

**프로듀서 생성**

- 코루틴 빌더 produce() 호출 -> ReceiveChannel<E> 반환
- 프로듀서는 채널 위에 구축되므로 프로듀서의 요소를 산출하기 위해 send(E) 함수 사용
  
**프로듀서 모든 요소 보기**
  
- consumerEach()
  
**단일 요소 박기**
  
- receive()
  
**요소 그룹 가져오기**

- take()의 매개변수로 요소의 개수를 제공해서 값을 읽을 수 있음
- ReceiveChannel<E>의 take()는 ReceiveChennel<E>를 반환
- take()는 중간 연산이므로 종단 연산이 발생할 때 요소의 실제 연산 값이 계산
  
**사용 가능한 요소 보다 더 많은 요소를 사용한 경우**
- consumerEach()는 더 이상 요소가 없으면 중단되기 때문에, 별도의 exception X
